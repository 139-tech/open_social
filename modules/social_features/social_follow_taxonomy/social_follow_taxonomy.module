<?php

/**
 * @file
 * Contains social_follow_taxonomy.module.
 */

use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\Url;
use Drupal\flag\Entity\Flag;
use Drupal\flag\FlagInterface;
use Drupal\message\Entity\Message;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function social_follow_taxonomy_theme($existing, $type, $theme, $path) {
  return [
    'flag__follow_term' => [
      'base hook' => 'flag',
    ],
    'activity__node__followed' => [
      'base hook' => 'activity',
    ],
  ];
}

/**
 * Implements hook_social_user_account_header_account_links().
 *
 * Adds the "Following tags" link to the user menu.
 */
function social_follow_taxonomy_social_user_account_header_account_links(array $context) {
  return [
    'my_tags' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup("View tags I'm following"),
      ],
      '#title' => new TranslatableMarkup('Following tags'),
      '#weight' => 1001,
    ] + Url::fromRoute('view.following_tags.following_tags')->toRenderArray(),
  ];
}

/**
 * Implements hook_page_attachments().
 */
function social_follow_taxonomy_page_attachments(array &$page) {
  $page['#attached']['library'][] = 'social_follow_taxonomy/social_follow_taxonomy';
}

/**
 * Implements hook_theme_suggestions_alter().
 *
 * Add new activity stream message template for nodes with a term followed by
 * the user to make it possible to override the default template.
 */
function social_follow_taxonomy_theme_suggestions_activity(array $variables) {
  $suggestions = [];

  $activity = $variables['elements']['#activity'];
  // Get a message entity from the activity.
  $message = Message::load($activity->field_activity_message->target_id);

  // Get the name of the template from the data of the message entity.
  if ($message->getTemplate()->id() == 'create_node_following_tag_stream') {
    $entity_type = $activity->field_activity_entity->first()->target_type;

    if ($entity_type === 'node') {
      $suggestions[] = 'activity__' . $entity_type . '__followed';
    }
  }

  return $suggestions;
}

/**
 * Extends variables for activity template.
 *
 * Implements hook_preprocess_activity().
 * {@inheritdoc}
 */
function social_follow_taxonomy_preprocess_activity(&$variables) {
  $activity = $variables['elements']['#activity'];

  $message = Message::load($activity->field_activity_message->target_id);
  $message_template_id = $message->getTemplate()->id();

  if ($message_template_id == 'create_node_following_tag_stream') {
    $entity = $activity->getRelatedEntity();

    if ($entity->getEntityTypeId() === 'node') {
      $taxonomy_ids = [];
      $storage = \Drupal::entityTypeManager()->getStorage('flagging');

      if ($entity instanceof NodeInterface) {
        if ($entity->hasField('social_tagging')) {
          if (!empty($tags = $entity->get('social_tagging')->getValue())) {
            foreach ($tags as $tag) {
              $taxonomy_ids[] = $tag['target_id'];
            }
          }
        }

        foreach ($taxonomy_ids as $taxonomy_id) {
          $flag = $storage->loadByProperties([
            'flag_id' => 'follow_term',
            'entity_type' => 'taxonomy_term',
            'entity_id' => $taxonomy_id,
            'uid' => \Drupal::currentUser()->id(),
          ]);
          $flag = reset($flag);

          if (!empty($flag)) {
            /** @var \Drupal\taxonomy\TermInterface $term */
            $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($taxonomy_id);
            $variables['content_type'] = $entity->type->entity->label();
            $variables['followed_tags'][$taxonomy_id] = [
              'name' => $term->getName(),
              'flag' => _social_follow_taxonomy_flag_link($term),
            ];
          }
        }
      }
    }
  }
}

/**
 * Implements hook_token_info().
 */
function social_follow_taxonomy_token_info() {

  $type = [
    'name' => t('Social Follow Taxonomy'),
    'description' => t('Tokens from the Social Follow Taxonomy module.'),
  ];

  $social_taxonomy['taxonomy_i_follow'] = [
    'name' => t('Taxonomy I follow.'),
    'description' => t('Taxonomy term I follow'),
  ];

  return [
    'types' => ['social_taxonomy' => $type],
    'tokens' => [
      'social_taxonomy' => $social_taxonomy,
    ],
  ];
}

/**
 * Implements hook_tokens().
 *
 * { @inheritdoc }
 */
function social_follow_taxonomy_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];
  $names = [];

  if ($type === 'social_taxonomy' && !empty($data['message'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'taxonomy_i_follow':
          $entity_id = $data['message']->getFieldValue('field_message_related_object', 'target_id');
          if (!empty($entity_id)) {
            $node_storage = \Drupal::entityTypeManager()->getStorage('node');
            /** @var \Drupal\node\Entity\Node $node */
            $node = $node_storage->load($entity_id);
            if ($node !== NULL) {
              if ($node->hasField('social_tagging')) {
                if (!empty($node->get('social_tagging')->getValue())) {
                  $tags = $node->get('social_tagging')->getValue();

                  foreach ($tags as $tag) {
                    /** @var \Drupal\taxonomy\TermInterface $term */
                    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tag['target_id']);
                    if ($term instanceof TermInterface) {
                      if (social_follow_taxonomy_term_followed($term)) {
                        $names[] = $term->getName();
                      }
                    }
                  }
                }
              }
            }
          }

          // String with term names in quotation marks, separated by commas.
          $replacement_string = "'" . implode("', '", $names) . "'";
          $replacements[$original] = $replacement_string;
          break;
      }
    }
  }

  return $replacements;
}

/**
 * Function to check if term is followed.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return bool
 *   Follow result.
 */
function social_follow_taxonomy_term_followed(TermInterface $term) {
  $follow = FALSE;

  if (!\Drupal::currentUser()->isAnonymous()) {
    $flag = Flag::load('follow_term');
    if ($flag instanceof FlagInterface) {
      /** @var \Drupal\flag\FlagService $service */
      $service = \Drupal::service('flag');
      if (!empty($service->getFlagging($flag, $term, \Drupal::currentUser()))) {
        $follow = TRUE;
      }
    }
  }

  return $follow;
}

/**
 * A function that prepares a flag link for a taxonomy term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return string
 *   Link button to flag/unflag current term.
 */
function _social_follow_taxonomy_flag_link(TermInterface $term) {
  $flag_link = '';

  if (!\Drupal::currentUser()->isAnonymous()) {
    $flag_link_service = \Drupal::service('flag.link_builder');
    $flag_link = $flag_link_service->build($term->getEntityTypeId(), $term->id(), 'follow_term');
  }

  return $flag_link;
}
