<?php

/**
 * @file
 * Contains social_follow_taxonomy.module.
 */

use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\Url;
use Drupal\flag\Entity\Flag;
use Drupal\flag\FlagInterface;
use Drupal\message\Entity\Message;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function social_follow_taxonomy_theme($existing, $type, $theme, $path) {
  return [
    'flag__follow_term' => [
      'base hook' => 'flag',
    ],
    'activity__node__followed' => [
      'base hook' => 'activity',
    ],
  ];
}

/**
 * Implements hook_social_user_account_header_account_links().
 *
 * Adds the "Following tags" link to the user menu.
 */
function social_follow_taxonomy_social_user_account_header_account_links(array $context) {
  return [
    'my_tags' => [
      '#type' => 'link',
      '#attributes' => [
        'title' => new TranslatableMarkup("View tags I'm following"),
      ],
      '#title' => new TranslatableMarkup('Following tags'),
      '#weight' => 1001,
    ] + Url::fromRoute('view.following_tags.following_tags')->toRenderArray(),
  ];
}

/**
 * Implements hook_page_attachments().
 */
function social_follow_taxonomy_page_attachments(array &$page) {
  $page['#attached']['library'][] = 'social_follow_taxonomy/social_follow_taxonomy';
}

/**
 * Implements hook_theme_suggestions_alter().
 *
 * Add new activity stream message template for nodes with a term followed by
 * the user to make it possible to override the default template.
 */
function social_follow_taxonomy_theme_suggestions_activity(array $variables) {
  $suggestions = [];

  $activity = $variables['elements']['#activity'];
  // Get a message entity from the activity.
  $message = Message::load($activity->field_activity_message->target_id);

  // Get the name of the template from the data of the message entity.
  if ($message->getTemplate()->id() == 'create_node_following_tag_stream') {
    $entity_type = $activity->field_activity_entity->first()->target_type;

    if ($entity_type === 'node') {
      $suggestions[] = 'activity__' . $entity_type . '__followed';
    }
  }

  return $suggestions;
}

/**
 * Extends variables for activity template.
 *
 * Implements hook_preprocess_activity().
 * {@inheritdoc}
 */
function social_follow_taxonomy_preprocess_activity(&$variables) {
  $activity = $variables['elements']['#activity'];

  $message = Message::load($activity->field_activity_message->target_id);
  $message_template_id = $message->getTemplate()->id();

  if ($message_template_id == 'create_node_following_tag_stream') {
    $entity = $activity->getRelatedEntity();

    if ($entity->getEntityTypeId() === 'node') {
      $taxonomy_ids = [];
      $storage = \Drupal::entityTypeManager()->getStorage('flagging');

      if ($entity instanceof NodeInterface) {
        if ($entity->hasField('social_tagging')) {
          if (!empty($tags = $entity->get('social_tagging')->getValue())) {
            foreach ($tags as $tag) {
              $taxonomy_ids[] = $tag['target_id'];
            }
          }
        }

        foreach ($taxonomy_ids as $taxonomy_id) {
          $flag = $storage->loadByProperties([
            'flag_id' => 'follow_term',
            'entity_type' => 'taxonomy_term',
            'entity_id' => $taxonomy_id,
            'uid' => \Drupal::currentUser()->id(),
          ]);
          $flag = reset($flag);

          if (!empty($flag)) {
            /** @var \Drupal\taxonomy\TermInterface $term */
            $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($taxonomy_id);
            $variables['content_type'] = $entity->type->entity->label();
            $variables['followed_tags'][$taxonomy_id] = [
              'name' => $term->getName(),
              'flag' => social_follow_taxonomy_flag_link($term),
            ];
          }
        }
      }
    }
  }
}

/**
 * Implements hook_token_info().
 */
function social_follow_taxonomy_token_info() {

  $type = [
    'name' => t('Social Follow Taxonomy'),
    'description' => t('Tokens from the Social Follow Taxonomy module.'),
  ];

  $social_taxonomy['content_type'] = [
    'name' => t('The content type.'),
    'description' => t('The type of the content that is related to following term.'),
  ];

  return [
    'types' => ['social_taxonomy' => $type],
    'tokens' => [
      'social_taxonomy' => $social_taxonomy,
    ],
  ];
}

/**
 * Implements hook_tokens().
 *
 * { @inheritdoc }
 */
function social_follow_taxonomy_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];

  if ($type === 'social_taxonomy' && !empty($data['message'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'content_type':
          /** @var \Drupal\message\Entity\Message $message */
          $message = $data['message'];
          // Get the related entity.
          if (isset($message->field_message_related_object)) {
            $target_type = $message->field_message_related_object->target_type;
            $target_id = $message->field_message_related_object->target_id;
            $entity = \Drupal::entityTypeManager()
              ->getStorage($target_type)
              ->load($target_id);

            if (is_object($entity)) {
              switch ($target_type) {
                case 'node':
                  $display_name = strtolower($entity->type->entity->label());
                  break;
              }

              // When a name of content name starts from a vowel letter then
              // will be added "an" before this name. For example "an
              // event".
              if (isset($display_name)) {
                if (preg_match('/^[aeiou]/', $display_name)) {
                  $display_name = t('an @content_type', ['@content_type' => $display_name]);
                }
                else {
                  $display_name = t('a @content_type', ['@content_type' => $display_name]);
                }
                $replacements[$original] = $display_name;
              }
            }
          }
          break;

      }
    }
  }

  return $replacements;
}

/**
 * Function to check if term is followed.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return bool
 *   Follow result.
 */
function social_follow_taxonomy_term_followed(TermInterface $term) {
  $follow = FALSE;

  if (!\Drupal::currentUser()->isAnonymous()) {
    $flag = Flag::load('follow_term');
    if ($flag instanceof FlagInterface) {
      /** @var \Drupal\flag\FlagService $service */
      $service = \Drupal::service('flag');
      if (!empty($service->getFlagging($flag, $term, \Drupal::currentUser()))) {
        $follow = TRUE;
      }
    }
  }

  return $follow;
}

/**
 * Function for counting the number of followers of the term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return int
 *   Count of followers.
 */
function social_follow_taxonomy_term_followers_count(TermInterface $term) {
  $count = 0;
  $term_followers_count = \Drupal::service('flag.count')->getEntityFlagCounts($term);

  if (isset($term_followers_count['follow_term'])) {
    $count = $term_followers_count['follow_term'];
  }

  return $count;
}

/**
 * A function that prepares a flag link for a taxonomy term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return string
 *   Link button to flag/unflag current term.
 */
function social_follow_taxonomy_flag_link(TermInterface $term) {
  $flag_link = '';

  if (!\Drupal::currentUser()->isAnonymous()) {
    $flag_link_service = \Drupal::service('flag.link_builder');
    $flag_link = $flag_link_service->build($term->getEntityTypeId(), $term->id(), 'follow_term');
  }

  return $flag_link;
}

/**
 * Function for counting the number of nodes related to the term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 * @param string $field_id
 *   Taxonomy term reference field id.
 *
 * @return int
 *   Count of related nodes.
 */
function social_follow_taxonomy_related_nodes_count(TermInterface $term, $field_id) {
  $nodes = \Drupal::entityTypeManager()
    ->getStorage('node')
    ->loadByProperties([$field_id => $term->id()]);

  return count($nodes);
}

/**
 * Implements hook_views_data().
 */
function social_follow_taxonomy_views_data() {
  $data['activity']['activity_follow_taxonomy_visibility_access_filter'] = [
    'title' => t('Filter on taxonomy activities for the personalised homepage.'),
    'filter' => [
      'title' => t('Filter following taxonomy activities for personalised homepage'),
      'help' => t('Filter following taxonomy on activities for personalised homepage.'),
      'field' => 'field_visibility',
      'id' => 'activity_follow_taxonomy_visibility_access',
    ],
  ];
  return $data;
}
