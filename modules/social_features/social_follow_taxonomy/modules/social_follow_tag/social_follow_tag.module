<?php

/**
 * @file
 * Contains social_follow_tag.module.
 */

use Drupal\Core\Url;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function social_follow_tag_theme() {
  return [
    'paragraph__tag__default' => [
      'base hook' => 'paragraph',
    ],
    'social_tagging_nosplit' => [
      'base hook' => 'social_tagging_nosplit',
    ],
    'social_tagging_split' => [
      'base hook' => 'social_tagging_split',
    ],
    'search_follow_tag' => [
      'variables' => ['tags' => NULL],
    ],
  ];

}

/**
 * Prepares variables for the Tag paragraph template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_paragraph(&$variables) {
  /** @var \Drupal\paragraphs\Entity\Paragraph $entity */
  $entity = $variables['elements']['#paragraph'];
  $bundle = $entity->bundle();

  switch ($bundle) {
    case 'tag':
      if ($entity->hasField('field_tag') && !empty($entity->field_tag)) {
        $term_id = $entity->field_tag->target_id;
        /** @var \Drupal\taxonomy\TermStorageInterface $term_storage */
        $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
        /** @var \Drupal\taxonomy\TermInterface $term */
        $term = $term_storage->load($term_id);

        if (!empty($term)) {
          // Creates a link to a search page with a tag as a filter parameter.
          $parameter = 'tag';
          $route = 'view.search_content.page_no_value';
          $parents = $term_storage->loadParents($term_id);
          if (!empty($parents)) {
            $parent = reset($parents);
            $category = $parent->getName();

            if ($tag_service = Drupal::getContainer()->get('social_tagging.tag_service')->allowSplit()) {
              $parameter = social_tagging_to_machine_name($category);
            }
          }
          $url = Url::fromRoute($route, [
            $parameter . '[]' => $term_id,
          ]);

          // Adding additional data to the term variable to extend the template.
          $variables['term'] = [
            'url' => $url->toString(),
            'name' => $term->getName(),
            'flag' => _social_follow_taxonomy_flag_link($term),
            'related_content' => _social_follow_tag_related_content($term),
          ];
        }
      }
      break;
  }
}

/**
 * Extends variables for social_tagging_split template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_split(&$variables) {
  if (!isset($variables['taghierarchy'])) {
    return;
  }

  // Iterate over an array with parent terms (category).
  foreach ($variables['taghierarchy'] as $parent_tag) {
    if (!isset($parent_tag['tags'])) {
      continue;
    }
    // Iterate over an array with terms in each category.
    foreach ($parent_tag['tags'] as $tag_id => $tag_info) {
      /** @var \Drupal\taxonomy\TermStorageInterface $term_storage */
      $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
      $current_term = $term_storage->load($tag_id);
      // Must be a valid Term.
      if (!$current_term instanceof TermInterface) {
        continue;
      }
      // Get current term parent.
      $parents = $term_storage->loadParents($current_term->id());
      if (!empty($parents)) {
        $parent = reset($parents);

        // Adding additional data to the term variable to extend the template.
        $variables['taghierarchy'][$parent->id()]['tags'][$current_term->id()] = [
          'url' => $tag_info['url'],
          'name' => $tag_info['name'],
          'flag' => _social_follow_taxonomy_flag_link($current_term),
          'related_content' => _social_follow_tag_related_content($current_term),
          'follow' => social_follow_taxonomy_term_followed($current_term),
        ];
      }
    }
  }
}

/**
 * Extends variables for social_tagging_nosplit template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_nosplit(&$variables) {
  if (!isset($variables['tags'])) {
    return;
  }

  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');

  foreach ($variables['tags'] as $tag_name => $tag_info) {
    // Get term id from the transmitted url string.
    $term_id_from_string = explode('/search/content?tag%5B%5D=', $tag_info);
    if (isset($term_id_from_string[1])) {
      $current_term = $term_storage->load($term_id_from_string[1]);
    }

    // Must be a valid Term.
    if (!isset($current_term) || !$current_term instanceof TermInterface) {
      continue;
    }

    // Adding additional data to the term variable to extend the template.
    $variables['tags'][$tag_name] = [
      'url' => $tag_info,
      'name' => $tag_name,
      'flag' => _social_follow_taxonomy_flag_link($current_term),
      'related_content' => _social_follow_tag_related_content($current_term),
      'follow' => social_follow_taxonomy_term_followed($current_term),
    ];
  }
}

/**
 * Function for counting the number of content related to the term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return array
 *   Array with related content.
 */
function _social_follow_tag_related_content(TermInterface $term) {
  $related_content = [];
  $nodes = \Drupal::entityTypeManager()
    ->getStorage('node')
    ->loadByProperties(['social_tagging' => $term->id()]);

  /** @var \Drupal\node\Entity\Node $node */
  foreach ($nodes as $node) {
    $related_content[$node->bundle()]['label'] = $node->type->entity->label();
    // Counting the number of nodes separately for each type.
    if (isset($related_content[$node->bundle()]['count'])) {
      $related_content[$node->bundle()]['count'] += 1;
    }
    else {
      $related_content[$node->bundle()]['count'] = 1;
    }
  }

  return $related_content;
}
