<?php

/**
 * @file
 * Contains social_follow_tag.module.
 */

use Drupal\Core\Url;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function social_follow_tag_theme() {
  return [
    'paragraph__tag__default' => [
      'base hook' => 'paragraph',
    ],
    'social_tagging_nosplit' => [
      'base hook' => 'social_tagging_nosplit',
    ],
    'social_tagging_split' => [
      'base hook' => 'social_tagging_split',
    ],
    'block__inline_block__follow_tags' => [
      'base hook' => 'block',
    ],
    'search_follow_tag' => [
      'variables' => ['tags' => NULL],
    ],
  ];

}

/**
 * Prepares variables for the Tag paragraph template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_paragraph(&$variables) {
  $terms = [];
  /** @var \Drupal\paragraphs\Entity\Paragraph $entity */
  $entity = $variables['elements']['#paragraph'];
  $bundle = $entity->bundle();

  switch ($bundle) {
    case 'tag':
      if ($entity->hasField('field_tag') && !empty($entity->field_tag)) {
        foreach ($entity->field_tag as $term_reference) {
          /** @var \Drupal\taxonomy\TermInterface $term */
          $term = $term_reference->entity;

          if (!empty($term)) {
            // Creates a link to a search page with a tag as a filter parameter.
            $parameter = 'tag';
            $route = 'view.search_content.page_no_value';
            // Override filter parameter id if split option is enabled.
            if (Drupal::getContainer()->get('social_tagging.tag_service')->allowSplit()) {
              if (isset($term->parent)) {
                $parent = $term->parent->entity;
                if (!empty($parent)) {
                  $category = $parent->getName();
                  // Use the name of parent term as id of the filter parameter.
                  $parameter = social_tagging_to_machine_name($category);
                }
              }
            }
            $url = Url::fromRoute($route, [
              $parameter . '[]' => $term->id(),
            ]);

            // Prepare additional data for the term variables.
            $terms[] = [
              'url' => $url->toString(),
              'name' => $term->getName(),
              'flag' => _social_follow_taxonomy_flag_link($term),
              'related_nodes_count' => _social_follow_tag_related_nodes_count($term),
              'followers_count' => social_follow_taxonomy_term_followers_count($term),
            ];
          }
        }

        // Adding data to the terms variable to extend the template.
        $variables['terms'] = $terms;
      }
      break;
  }
}

/**
 * Extends variables for social_tagging_split template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_split(&$variables) {
  if (!isset($variables['taghierarchy'])) {
    return;
  }

  // Iterate over an array with parent terms (category).
  foreach ($variables['taghierarchy'] as $parent_tag) {
    if (!isset($parent_tag['tags'])) {
      continue;
    }
    // Iterate over an array with terms in each category.
    foreach ($parent_tag['tags'] as $tag_id => $tag_info) {
      /** @var \Drupal\taxonomy\TermStorageInterface $term_storage */
      $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
      $current_term = $term_storage->load($tag_id);
      // Must be a valid Term.
      if (!$current_term instanceof TermInterface) {
        continue;
      }
      // Get current term parent.
      $parents = $term_storage->loadParents($current_term->id());
      if (!empty($parents)) {
        $parent = reset($parents);

        // Adding additional data to the term variable to extend the template.
        $variables['taghierarchy'][$parent->id()]['tags'][$current_term->id()] = [
          'url' => $tag_info['url'],
          'name' => $tag_info['name'],
          'flag' => _social_follow_taxonomy_flag_link($current_term),
          'related_nodes_count' => _social_follow_tag_related_nodes_count($current_term),
          'followers_count' => social_follow_taxonomy_term_followers_count($current_term),
          'follow' => social_follow_taxonomy_term_followed($current_term),
        ];
      }
    }
  }
}

/**
 * Extends variables for social_tagging_nosplit template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_nosplit(&$variables) {
  if (!isset($variables['tags'])) {
    return;
  }

  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');

  foreach ($variables['tags'] as $tag_name => $tag_info) {
    // Get term id from the transmitted url string.
    $term_id_from_string = explode('/search/content?tag%5B%5D=', $tag_info);
    if (isset($term_id_from_string[1])) {
      $current_term = $term_storage->load($term_id_from_string[1]);
    }

    // Must be a valid Term.
    if (!isset($current_term) || !$current_term instanceof TermInterface) {
      continue;
    }

    // Adding additional data to the term variable to extend the template.
    $variables['tags'][$tag_name] = [
      'url' => $tag_info,
      'name' => $tag_name,
      'flag' => _social_follow_taxonomy_flag_link($current_term),
      'related_nodes_count' => _social_follow_tag_related_nodes_count($current_term),
      'followers_count' => social_follow_taxonomy_term_followers_count($current_term),
      'follow' => social_follow_taxonomy_term_followed($current_term),
    ];
  }
}

/**
 * Function for counting the number of nodes related to the term.
 *
 * @param \Drupal\taxonomy\TermInterface $term
 *   Term entity.
 *
 * @return int
 *   Count of related nodes.
 */
function _social_follow_tag_related_nodes_count(TermInterface $term) {
  $nodes = \Drupal::entityTypeManager()
    ->getStorage('node')
    ->loadByProperties(['social_tagging' => $term->id()]);

  return count($nodes);
}
