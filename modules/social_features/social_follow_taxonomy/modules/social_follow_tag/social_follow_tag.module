<?php

/**
 * @file
 * Contains social_follow_tag.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\Url;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function social_follow_tag_theme() {
  return [
    'paragraph__tag__default' => [
      'base hook' => 'paragraph',
    ],
    'social_tagging_nosplit' => [
      'base hook' => 'social_tagging_nosplit',
    ],
    'social_tagging_split' => [
      'base hook' => 'social_tagging_split',
    ],
    'block__inline_block__follow_tags' => [
      'base hook' => 'block',
    ],
    'search_follow_tag' => [
      'variables' => ['tags' => NULL],
    ],
  ];

}

/**
 * Implements hook_token_info().
 */
function social_follow_tag_token_info() {
  $social_tag['taxonomy_i_follow'] = [
    'name' => t('Taxonomy I follow.'),
    'description' => t('Taxonomy term I follow'),
  ];

  return [
    'tokens' => [
      'social_taxonomy' => $social_tag,
    ],
  ];
}

/**
 * Implements hook_tokens().
 *
 * { @inheritdoc }
 */
function social_follow_tag_tokens($type, $tokens, array $data, array $options, BubbleableMetadata $bubbleable_metadata) {
  $replacements = [];
  $names = [];

  if ($type === 'social_taxonomy' && !empty($data['message'])) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'taxonomy_i_follow':
          $entity_id = $data['message']->getFieldValue('field_message_related_object', 'target_id');
          if (!empty($entity_id)) {
            $node_storage = \Drupal::entityTypeManager()->getStorage('node');
            /** @var \Drupal\node\Entity\Node $node */
            $node = $node_storage->load($entity_id);
            if ($node !== NULL) {
              if ($node->hasField('social_tagging')) {
                if (!empty($node->get('social_tagging')->getValue())) {
                  $tags = $node->get('social_tagging')->getValue();

                  foreach ($tags as $tag) {
                    /** @var \Drupal\taxonomy\TermInterface $term */
                    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tag['target_id']);
                    if ($term instanceof TermInterface) {
                      if (social_follow_taxonomy_term_followed($term)) {
                        $names[] = $term->getName();
                      }
                    }
                  }
                }
              }
            }
          }

          // String with term names in quotation marks, separated by commas.
          $replacement_string = "'" . implode("', '", $names) . "'";
          $replacements[$original] = $replacement_string;
          break;
      }
    }
  }

  return $replacements;
}

/**
 * Prepares variables for the Tag paragraph template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_paragraph(&$variables) {
  $terms = [];
  /** @var \Drupal\paragraphs\Entity\Paragraph $entity */
  $entity = $variables['elements']['#paragraph'];
  $bundle = $entity->bundle();

  switch ($bundle) {
    case 'tag':
      if ($entity->hasField('field_tag') && !empty($entity->field_tag)) {
        foreach ($entity->field_tag as $term_reference) {
          /** @var \Drupal\taxonomy\TermInterface $term */
          $term = $term_reference->entity;

          if (!empty($term)) {
            // Creates a link to a search page with a tag as a filter parameter.
            $parameter = 'tag';
            $route = 'view.search_content.page_no_value';
            // Override filter parameter id if split option is enabled.
            if (Drupal::getContainer()->get('social_tagging.tag_service')->allowSplit()) {
              if (isset($term->parent)) {
                $parent = $term->parent->entity;
                if (!empty($parent)) {
                  $category = $parent->getName();
                  // Use the name of parent term as id of the filter parameter.
                  $parameter = social_tagging_to_machine_name($category);
                }
              }
            }
            $url = Url::fromRoute($route, [
              $parameter . '[]' => $term->id(),
            ]);

            // Prepare additional data for the term variables.
            $terms[] = [
              'url' => $url->toString(),
              'name' => $term->getName(),
              'flag' => social_follow_taxonomy_flag_link($term),
              'related_nodes_count' => social_follow_taxonomy_related_nodes_count($term, 'social_tagging'),
              'followers_count' => social_follow_taxonomy_term_followers_count($term),
            ];
          }
        }

        // Adding data to the terms variable to extend the template.
        $variables['terms'] = $terms;
      }
      break;
  }
}

/**
 * Extends variables for social_tagging_split template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_split(&$variables) {
  if (!isset($variables['taghierarchy'])) {
    return;
  }

  // Iterate over an array with parent terms (category).
  foreach ($variables['taghierarchy'] as $parent_tag) {
    if (!isset($parent_tag['tags'])) {
      continue;
    }
    // Iterate over an array with terms in each category.
    foreach ($parent_tag['tags'] as $tag_id => $tag_info) {
      /** @var \Drupal\taxonomy\TermStorageInterface $term_storage */
      $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
      $current_term = $term_storage->load($tag_id);
      // Must be a valid Term.
      if (!$current_term instanceof TermInterface) {
        continue;
      }
      // Get current term parent.
      $parents = $term_storage->loadParents($current_term->id());
      if (!empty($parents)) {
        $parent = reset($parents);

        // Adding additional data to the term variable to extend the template.
        $variables['taghierarchy'][$parent->id()]['tags'][$current_term->id()] = [
          'url' => $tag_info['url'],
          'name' => $tag_info['name'],
          'flag' => social_follow_taxonomy_flag_link($current_term),
          'related_nodes_count' => social_follow_taxonomy_related_nodes_count($current_term, 'social_tagging'),
          'followers_count' => social_follow_taxonomy_term_followers_count($current_term),
          'follow' => social_follow_taxonomy_term_followed($current_term),
        ];
      }
    }
  }
}

/**
 * Extends variables for social_tagging_nosplit template.
 *
 * Implements hook_preprocess_HOOK().
 * {@inheritdoc}
 */
function social_follow_tag_preprocess_social_tagging_nosplit(&$variables) {
  if (!isset($variables['tags'])) {
    return;
  }

  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');

  foreach ($variables['tags'] as $tag_name => $tag_info) {
    // Get term id from the transmitted url string.
    $term_id_from_string = explode('/search/content?tag%5B%5D=', $tag_info);
    if (isset($term_id_from_string[1])) {
      $current_term = $term_storage->load($term_id_from_string[1]);
    }

    // Must be a valid Term.
    if (!isset($current_term) || !$current_term instanceof TermInterface) {
      continue;
    }

    // Adding additional data to the term variable to extend the template.
    $variables['tags'][$tag_name] = [
      'url' => $tag_info,
      'name' => $tag_name,
      'flag' => social_follow_taxonomy_flag_link($current_term),
      'related_nodes_count' => social_follow_taxonomy_related_nodes_count($current_term, 'social_tagging'),
      'followers_count' => social_follow_taxonomy_term_followers_count($current_term),
      'follow' => social_follow_taxonomy_term_followed($current_term),
    ];
  }
}

/**
 * Create a notification when tags followed by a user are added to the node.
 *
 * Implements hook_entity_update().
 * {@inheritdoc}
 */
function social_follow_tag_entity_update(EntityInterface $entity) {
  $taxonomy_ids = [];
  $original_taxonomy_ids = [];

  /** @var \Drupal\social_queue_storage\Entity\QueueStorageEntity $entity */
  if ($entity->getEntityTypeId() === 'node') {
    // Prepare list of tags before update node.
    if ($original_entity = $entity->original) {
      if ($original_entity->hasField('social_tagging')) {
        if (!empty($original_entity->get('social_tagging')->getValue())) {
          $original_tags = $original_entity->get('social_tagging')->getValue();

          foreach ($original_tags as $original_tag) {
            $original_taxonomy_ids[] = $original_tag['target_id'];
          }
        }
      }
    }

    // Prepare list of tags after update node.
    if ($entity->hasField('social_tagging')) {
      if (!empty($entity->get('social_tagging')->getValue())) {
        $tags = $entity->get('social_tagging')->getValue();

        foreach ($tags as $tag) {
          // Check if new tags have been added after the update.
          if (!in_array($tag['target_id'], $original_taxonomy_ids)) {
            $taxonomy_ids[] = $tag['target_id'];
          }
        }
      }
    }

    // Set the creation time because it is used as notification creation time.
    $entity->setCreatedTime($entity->getChangedTime());
    // Set the owner id because it is used as the id of the notification author.
    $entity->setOwnerId(\Drupal::currentUser()->id());

    // Create activity notification.
    if (!empty($taxonomy_ids)) {
      \Drupal::service('plugin.manager.activity_action.processor')
        ->createInstance('update_entity_action')
        ->create($entity);
    }
  }
}
